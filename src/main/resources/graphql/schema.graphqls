type Query {
    user(id: ID!): User
    userByUsername(username: String!): User
    users(role: Role): [User!]!
    me: User
}

type Mutation {
    # Authentication
    login(input: LoginInput!): AuthResponse!
    logout: Boolean!
    refreshToken(refreshToken: String!): AuthResponse!

    # User management
    register(input: RegisterInput!): User!  # role optional, default STUDENT
    updateUser(id: ID!, input: UpdateUserInput!): User!
    changePassword(id: ID!, newPassword: String!): Boolean!
    changeRole(id: ID!, role: Role!): User!
    enableUser(id: ID!): Boolean!
    disableUser(id: ID!): Boolean!
    deleteUser(id: ID!): Boolean!

    # Message sending
    sendMessage(input: SendMessageInput!): Message!
}

type User {
    id: ID!
    username: String!
    email: String!
    role: Role!
    enabled: Boolean!
    createdAt: String!
    updatedAt: String
}

type AuthResponse {
    accessToken: String!
    refreshToken: String!
    tokenType: String!
    expiresIn: Int!
    userId: String!
    username: String!
    role: Role!
    decodedAccessToken: String!
    decodedRefreshToken: String!
}

input LoginInput {
    username: String!
    password: String!
}

input RegisterInput {
    username: String!
    password: String!
    email: String!
    role: Role  # Optional - default STUDENT if not provided
}

input UpdateUserInput {
    username: String
    email: String
}

input SendMessageInput {
    receiverId: ID!
    content: String!
}

enum Role {
    ADMIN
    STUDENT
}

type Message {
    id: ID!
    senderId: ID
    receiverId: ID!
    content: String!
    timestamp: String
}

type Subscription {
    newUserRegistered: User!
    newMessageReceived(userId: ID!): Message!
}
